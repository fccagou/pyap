#!/usr/bin/env python
#

import os
import time
import thread
import wsgiref.simple_server as server
from db9 import Db9


port = 8080

OK_LED = Db9.PIN4
CRITICAL_LED = Db9.PIN7

# 3 color led.
WARNING_LED = Db9.PIN4 | Db9.PIN7

ACK = 0

current_status = OK_LED
got_security_alert = None


def blink():

    global serial_output
    global got_security_alert

    while got_security_alert is not None:

        serial_output.switch_on(CRITICAL_LED)
        serial_output.switch_off(OK_LED)
        time.sleep(0.2)
        serial_output.switch_off(CRITICAL_LED)
        serial_output.switch_on(OK_LED)
        time.sleep(0.2)


def switch_on_alert(start_response, led):

    global serial_output
    global current_status

    if got_security_alert is None:
        serial_output.switch_off(Db9.ALL_OUTPUT)
        serial_output.switch_on(led)

    current_status = led

    status = '200 OK'
    output = "led %s on\n" % led
    response_headers = [('Content-type', 'text/plain'),
                        ('Content-Length', str(len(output)))]
    start_response(status, response_headers)
    return [output]


def notfound(start_response, url):

    status = '404 NOT FOUND'
    output = "%s not found\n" % url
    response_headers = [('Content-type', 'text/plain'),
                        ('Content-Length', str(len(output)))]
    start_response(status, response_headers)
    return [output]


def alert_critical(start_response):

    return switch_on_alert(start_response, CRITICAL_LED)


def alert_warning(start_response):

    return switch_on_alert(start_response, WARNING_LED)


def alert_ok(start_response):

    return switch_on_alert(start_response, OK_LED)


def alert_security(start_response):

    global got_security_alert

    if got_security_alert is None:
        got_security_alert = 1
        thread.start_new_thread(blink, ())

    status = '200 OK'
    output = "security alerte !\n"
    response_headers = [('Content-type', 'text/plain'),
                        ('Content-Length', str(len(output)))]
    start_response(status, response_headers)
    return [output]


def alert_security_ack(start_response):

    global got_security_alert
    got_security_alert = None
    # wait thread ending
    time.sleep(1)
    return switch_on_alert(start_response, current_status)


def alert_ack(start_response):

    return switch_on_alert(start_response, OK_LED)


def pynotify_application(environ, start_response):

    if environ['PATH_INFO'] == "/alert/critical":
        return alert_critical(start_response)

    if environ['PATH_INFO'] == "/alert/warning":
        return alert_warning(start_response)

    if environ['PATH_INFO'] == "/alert/ok":
        return alert_ok(start_response)

    if environ['PATH_INFO'] == "/alert/ack":
        return alert_ack(start_response)

    if environ['PATH_INFO'] == "/alert/security":
        return alert_security(start_response)

    if environ['PATH_INFO'] == "/alert/security/ack":
        return alert_security_ack(start_response)

    return notfound(start_response, environ['PATH_INFO'])


serial_output = Db9('/dev/ttyUSB0')
serial_output.connect()
serial_output.switch_off(Db9.ALL_OUTPUT)
serial_output.switch_on(OK_LED)


httpd = server.make_server('', port, pynotify_application)
print "Serving HTTP on port %i..." % port
# Respond to requests until process is killed
httpd.serve_forever()


serial_output.disconnect()
