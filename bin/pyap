#!/usr/bin/env python
#

from __future__ import print_function

import sys
import os
import time
import signal
from threading import Thread
import wsgiref.simple_server as server
from db9 import Db9
import json

try:
    # For Python 3.0 and later
    from urllib.request import urlopen
except ImportError:
    # Fall back to Python 2's urllib2
    from urllib2 import urlopen



# -----------------------------------------------------------------
# Global Variables.
# -----------------------------------------------------------------
# Default web server listening port
LISTENING_PORT = 8080

# For debuging
verbose = False

# current higher status of alert.
current_global_status = 'ok'

# This flag is used to set/unset security alert to blink the notifiers.
got_security_alert = False

# Number of secondes fot autorefresh webstatus.
web_status_refresh_sec=30

# TODO: assemble NOTIFIERS, POLLERS and notifiers in new pyap/PollerPool class

# Notifiers declared notifiers in conf file or on command line.
NOTIFIERS = {}
# POLLERS declared in conf file or on command line
POLLERS = {}
# list of instanciated notifier object
notifiers=[]


# -----------------------------------------------------------------
# Informational functions.
# -----------------------------------------------------------------
def log(msg):
    global verbose
    if verbose:
        print ("[+] - ",msg)
    else:
        pass

def info(msg):
    global verbose
    if verbose:
        print ("[i] - ",msg)
    else:
        pass

def warning(msg):
    global verbose
    if verbose:
        print ("[!] - ",msg)
    else:
        pass

def error(msg):
    global verbose
    if verbose:
        print ("[-] - ",msg)
    else:
        pass


# -----------------------------------------------------------------
# Blink notifiers.
# -----------------------------------------------------------------

def blink(speed, again):

    global notifiers
    global current_global_status

    while again():
        for n in notifiers:
            n.off()
        time.sleep(speed)
        for n in notifiers:
            getattr(n, current_global_status)()
        time.sleep(speed)


# -----------------------------------------------------------------
# Poller status management.
# -----------------------------------------------------------------
def poller_get_status(notifiers,url,stop):
    global blinks_states
    global current_global_status

    while not stop():
        # get {"services":{ "ok":123, "warn":1, "crit":0, "unknown":0}}
        try:
            services = {'crit':0, 'warn':0, 'unknown':0, 'ok':0}
            for u in url:
                info ("[+] Get status from %s" % u )
                poller_response = urlopen(u).read()
                info("poller status ( %s )" % poller_response.rstrip())
                poller_status = json.loads(poller_response)
                for k in poller_status['services'].keys():
                    services[k] += poller_status['services'][k]

            info("Global status ( %s )" % services)

            if services['crit'] > 0:
                current_global_status='critical'

            elif services['warn'] > 0:
                current_global_status='warning'

            elif services['unknown'] > 0:
                current_global_status='unknown'

            elif services['ok'] > 0:
                current_global_status='ok'

            else:
                error("json error")

            if not got_security_alert:
                for n in notifiers:
                    getattr(n,current_global_status)()

        except:
            error("error while getting status %s " % (sys.exc_info()[0]))

        time.sleep(10)



# -----------------------------------------------------------------
#  HTTP API to manage notifiers status.
# -----------------------------------------------------------------

def switch_on_alert(start_response, alert_status):

    global current_global_status
    global notifiers
    global got_security_alert

    current_global_status = alert_status

    if not got_security_alert:
        for n in notifiers:
            getattr(n,current_global_status)()

    status = '200 OK'
    output = "Status is %s\n" % current_global_status
    response_headers = [('Content-type', 'text/plain'),
                        ('Content-Length', str(len(output)))]
    start_response(status, response_headers)
    return [output]


def notfound(start_response, url):

    status = '404 NOT FOUND'
    output = "%s not found\n" % url
    response_headers = [('Content-type', 'text/plain'),
                        ('Content-Length', str(len(output)))]
    start_response(status, response_headers)
    return [output]


def alert_critical(start_response):
    return switch_on_alert(start_response, 'critical')


def alert_warning(start_response):
    return switch_on_alert(start_response, 'warning')


def alert_ok(start_response):
    return switch_on_alert(start_response, 'ok')


def alert_security(start_response):
    global got_security_alert
    if not got_security_alert:
        got_security_alert=True
        Thread(target=blink, args=(0.6, lambda: got_security_alert)).start()

    status = '200 OK'
    output = "security alerte !\n"
    response_headers = [('Content-type', 'text/plain'),
                        ('Content-Length', str(len(output)))]
    start_response(status, response_headers)
    return [output]


def alert_security_ack(start_response):
    global got_security_alert
    got_security_alert=False
    # wait thread ending
    time.sleep(1)
    return switch_on_alert(start_response, current_global_status)


def alert_ack(start_response):
    return alert_ok(start_response)


# -----------------------------------------------------------------
# HTTP: default page showing all notifiers status.
# -----------------------------------------------------------------
def web_status(start_response):
    """Return web page with POLLERS status"""
    global POLLERS
    global got_security_alert
    global web_status_refresh_sec

    status = "200 OK"
    output="""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>pyap status</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="fccagou">
    <meta name="description" content="Get POLLERS status">
    <meta name="robots" content="all">
    <style>
    body { background: #252830; box-sizing: border-box; }
    .crit {color: white; background: #e64759; border-radius: 3px}
    .warn {color: orange; background: #e4d836; border-radius: 3px}
    .unknown {color: black; background: #aaaaaa; border-radius: 3px}
    .ok {color: black; background: #1bc98e; border-radius: 3px}
    .security {color: white; background: #ff0000; border-radius: 3px}

    .alz {padding: 20px !important }
    .anj {font-weight: bold; color: rgba(255, 255, 255, 0.65);font-size: 85%;
        letter-spacing: .15em;
        text-transform: uppercase;
    }
    .gq {float: left;}
    .gg {width: 25%}
    .ala {margin-bottom: 20px !important; margin-left: 10px}
    .fu {
       padding: 20px
    }
    </style>
</head>
<body><div class="fu">
    """
    try:
        if got_security_alert:
            output+="""<div class="gq gg ala"><div class="security"><div class="alz"><span class="anj">Security ALERT</span></div><p> /!\ </p></div></div>"""

        for p in POLLERS:
            poller_status = json.loads(urlopen(POLLERS[p]['url']).read())
            log(poller_status)
            cssclass='ok'
            if poller_status['services']['crit'] > 0:
                cssclass='crit'
            elif  poller_status['services']['warn'] > 0:
                cssclass='warn'
            elif  poller_status['services']['unknown'] > 0:
                cssclass='unknown'

	    try:	
		detail_url="""<a href="%s">more detail</a>""" % POLLERS[p]['detail_url']
	    except:
		detail_url=" "


            output+="""<div class="gq gg ala"><div class="%s"><div class="alz"><span class="anj"> %s</span></div><p>%s</p><p> %s, %s, %s, %s</p></div></div>""" % (cssclass,p,detail_url,poller_status['services']['ok'],poller_status['services']['warn'], poller_status['services']['crit'], poller_status['services']['unknown'])

        output += """</div><script>setInterval(function () { location.reload() }, %s000);</script></body></html>""" % (web_status_refresh_sec)
    except:
        status="500 INTERNAL ERROR"
        import traceback
        warning ("INTERNAL ERROR: %s " %  sys.exc_info()[0])
        print ('-'*60)
        traceback.print_exc(file=sys.stdout)
        print ('-'*60)
        output="Fuck"

    log(type(output))

    response_headers = [('Content-type', 'text/html; charset=UTF-8'),
                        ('Content-Length', str(len(output)))]
    start_response(status, response_headers)
    return [str(output)]

# -----------------------------------------------------------------
# HTTP: WEB APP
# -----------------------------------------------------------------
def pyap_application(environ, start_response):

    if environ['PATH_INFO'] == "/alert/critical":
        return alert_critical(start_response)

    if environ['PATH_INFO'] == "/alert/warning":
        return alert_warning(start_response)

    if environ['PATH_INFO'] == "/alert/ok":
        return alert_ok(start_response)

    if environ['PATH_INFO'] == "/alert/ack":
        return alert_ack(start_response)

    if environ['PATH_INFO'] == "/alert/security":
        return alert_security(start_response)

    if environ['PATH_INFO'] == "/alert/security/ack":
        return alert_security_ack(start_response)

    if environ['PATH_INFO'] == "/":
        return web_status(start_response)

    return notfound(start_response, environ['PATH_INFO'])


# -----------------------------------------------------------------
# MAIN PROGRAM.
# -----------------------------------------------------------------
def EndException(BaseException):
    def __init__(self, value):
        self.value=value
    def __str__(self):
        return repr(self.value)

def end_process(signum,frame):
    raise EndException('Signal catch')

def main(args):

    global verbose
    global notifiers
    global NOTIFIERS
    global POLLERS
    global got_security_alert

    verbose = args.verbose
    debug = args.debug

    # Catch signal to quit cleanly.
    signal.signal(signal.SIGTERM, end_process)
    signal.signal(signal.SIGQUIT, end_process)

    if debug:
        log ("args list: %s " %  args)

    # Get configuration from file.
    if args.conf is not None:
        log('Using config file %s' % args.conf)
        conf = json.loads(open(args.conf, 'r').read())
        NOTIFIERS = conf['NOTIFIERS']
	if 'POLLERS' in conf.keys():
            POLLERS = conf['POLLERS']
	# kept in v0.4.x for compatibility with 0.3.x versions
	# This will be removed in next version 0.5
	elif 'URLS' in conf.keys():
            POLLERS = conf['URLS']

    if debug:
        log ("NOTIFIERS: %s" % NOTIFIERS)
        log ("POLLERS: %s" % POLLERS)

    # Add notifiers passed in parameters if exist.
    if args.notifiers:
        for n in args.notifiers.split(','):
            if n == 'Blink1Notifier':
                NOTIFIERS[n] = {}
                NOTIFIERS[n]['type'] = n
                NOTIFIERS[n]['led'] = 0
                NOTIFIERS[n]['default_status'] = 'unknown'
                NOTIFIERS[n]['status'] = {}
                NOTIFIERS[n]['status']['ok'] = '#00FF00'
                NOTIFIERS[n]['status']['warn'] = '#FFFF00'
                NOTIFIERS[n]['status']['crit'] = '#FF0000'

    # Running without Notifier has no sense.
    if not len(NOTIFIERS):
        error('No notifier found !    C U Later !!')
        sys.exit(1)

    # Add Urls from parameters.
    for u in POLLERS:
        args.urls.append(POLLERS[u]['url'])

    # Creates all Notifiers objects from configuration.
    for n in NOTIFIERS:
        n_type = NOTIFIERS[n]['type']

        if n_type == 'Blink1Notifier':
            try:
                from pyap.blink1_notifier import Blink1Notifier
                blink1=Blink1Notifier(
                        led = NOTIFIERS[n]['led'],
                        state = NOTIFIERS[n]['default_status'],
                        ok_color = NOTIFIERS[n]['status']['ok'],
                        warn_color = NOTIFIERS[n]['status']['warn'],
                        crit_color = NOTIFIERS[n]['status']['crit'],
                        )
                log("Blink(1) found")
                notifiers.append(blink1)
            except:
                warning ("Blink(1) not found")
                if debug:
                    import traceback
                    warning ("Blink1 error: %s " %  sys.exc_info()[0])
                    print ('-'*60)
                    traceback.print_exc(file=sys.stdout)
                    print ('-'*60)
                    warning('No Blink(1) code. Look at get-blink1.sh')


        elif n_type == 'SerialLedNotifier':

            try:
                from pyap.serial_led_notifier import SerialLedNotifier
                serial_led=SerialLedNotifier(
                        NOTIFIERS[n]['tty'],
                        state=NOTIFIERS[n]['default_status'],
                        )
                log("serial_led found")
                notifiers.append(serial_led)
            except:
                warning("serial_led not found")
                serial_led=None
                if debug:
                    import traceback
                    warning ("SerialLed error: %s " %  sys.exc_info()[0])
                    print ('-'*60)
                    traceback.print_exc(file=sys.stdout)
                    print ('-'*60)

    poller = None

    stop_thread=False
    try:
        if args.server:
            # If local status server is run, the polling process
            # is run in a separate thread.
            if len(args.urls):
                log("Running http poller")
                poller = Thread(
                        target=poller_get_status,
                        args=(notifiers, args.urls,lambda: stop_thread)
                        )
                poller.start()

            port = args.port
            httpd = server.make_server('', port, pyap_application)
            log("Serving HTTP on port %i..." % port)
            # Respond to requests until process is killed
            httpd.serve_forever()
        else:
            if len(args.urls):
                poller_get_status(notifiers, args.urls, lambda: stop_thread)
            else:
                print ("[+] Nothing to poll or to serve... I leave ...")
    except KeyboardInterrupt:
        log('End asked by user...bye bye !')
    except EndException as ee:
        log(ee.value)
    except:
        print ("Unexpected error:", sys.exc_info()[0])
    finally:
        # Ending all process and switch notifiers off before leaving.
        stop_thread=True
        got_security_alert=False

        log("Waiting end of process")
        time.sleep(2)

        for n in notifiers:
            n.off()

if __name__ == '__main__':


    # Process passed arguments.
    try:
        import argparse
        parser = argparse.ArgumentParser(
            description='Notify processor.',
            )
        USING_ARGPARSE = True
    except ImportError:
        import optparse
        parser = optparse.OptionParser(
            description='PYthon Alert Processor.')
        parser.parse_args_orig = parser.parse_args
        parser.parse_args = lambda: parser.parse_args_orig()[0]
        parser.add_argument = parser.add_option
        USING_ARGPARSE = False

    parser.add_argument('--conf', '-c',
                        help='Configuration file.')
    parser.add_argument('--notifiers', '-n',
                        help='Notifiers list in Blink1Notifier,SerialLedNotifier')
    parser.add_argument('--server','-s', action='store_true',
                        help="Run http listening server (default=false)")
    parser.add_argument('--port', '-p', default=LISTENING_PORT, type=int,
                        help='Listening port for status push .')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Verbose.')
    parser.add_argument('--debug', '-d', action='store_true',
                        help='Debug mode.')
    parser.add_argument('--fg', action='store_true',
                        help='Forground mode. Disable daemon mode.')
    parser.add_argument('--nopid', action='store_true',
                        help='Disable writing pid file (see --pidfile)')
    parser.add_argument('--pidfile', default='/var/run/pyap.pid',
                        help='Set the pid file.')
    parser.add_argument('urls', nargs='*',
                        help='url for http state poller')

    args = parser.parse_args()

    if not args.fg:
        # do the UNIX double-fork magic, see Stevens' "Advanced
        # Programming in the UNIX Environment" for details (ISBN 0201563177)
        if args.debug or args.verbose:
            log('Running daemon mode.')

        if os.fork() > 0:
            sys.exit(0)

        # Decouple from parent environment
        os.chdir('/')
        os.setsid()
        # TODO os.umask()
        # Redirect the standard I/O file descriptors to /dev/null
        if hasattr(os, "devnull"):
            REDIRECT_TO = os.devnull
        else:
            REDIRECT_TO = "/dev/null"

        fd = os.open(REDIRECT_TO, os.O_RDWR)
        os.dup2(fd, 0)  # standard input (0)
        os.dup2(fd, 1)  # standard output (1)
        os.dup2(fd, 2)  # standard error (2)

        # Double-fork magic must be single-fork for systemd
        # TODO: test under centos6 using init.
        # if os.fork() > 0:
        #     sys.exit(0)

    if not args.nopid:
        with open(args.pidfile, 'w') as f:
            f.write(str(os.getpid()))

    main (args)

    if not args.nopid:
        os.remove(args.pidfile)

    os._exit(os.EX_OK)


